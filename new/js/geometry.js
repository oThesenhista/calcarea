// js/geometry.js

export function pontoDentroPoligono(ponto, poligono) { let dentro = false; for (let i = 0, j = poligono.length - 1; i < poligono.length; j = i++) { const xi = poligono[i].x, yi = poligono[i].y; const xj = poligono[j].x, yj = poligono[j].y; const intersect = ((yi > ponto.y) !== (yj > ponto.y)) && (ponto.x < (xj - xi) * (ponto.y - yi) / (yj - yi) + xi); if (intersect) dentro = !dentro; } return dentro; }
export function calcularArea(poligono) { let area = 0; for (let i = 0; i < poligono.length; i++) { const j = (i + 1) % poligono.length; area += poligono[i].x * poligono[j].y; area -= poligono[j].x * poligono[i].y; } return Math.abs(area / 2); }
export function distanciaPontoLinha(px, py, p1, p2) { const L2 = (p2.x - p1.x)**2 + (p2.y - p1.y)**2; if (L2 === 0) return Math.sqrt((px - p1.x)**2 + (py - p1.y)**2); let t = ((px - p1.x) * (p2.x - p1.x) + (py - p1.y) * (p2.y - p1.y)) / L2; t = Math.max(0, Math.min(1, t)); const projeçãoX = p1.x + t * (p2.x - p1.x); const projeçãoY = p1.y + t * (p2.y - p1.y); return Math.sqrt((px - projeçãoX)**2 + (py - projeçãoY)**2); }
export function retanguloCruzaPoligono(retangulo, poligono) { const { x, y, largura, altura } = retangulo; const cantos = [{ x, y }, { x: x + largura, y }, { x: x + largura, y: y + altura }, { x, y: y + altura }]; if (cantos.some(p => pontoDentroPoligono(p, poligono))) return true; if (poligono.some(p => p.x >= x && p.x <= x + largura && p.y >= y && p.y <= y + altura)) return true; for (let i = 0, j = poligono.length - 1; i < poligono.length; j = i++) { if (linhaCruzaRetangulo(poligono[i], poligono[j], { x, y, width: largura, height: altura })) return true; } return false; }
export function linhaCruzaRetangulo(p1, p2, retangulo) { const [rx, ry, rw, rh] = [retangulo.x, retangulo.y, retangulo.width, retangulo.height]; const retanguloPontos = [ { x: rx, y: ry }, { x: rx + rw, y: ry }, { x: rx + rw, y: ry + rh }, { x: rx, y: ry + rh } ]; for (let i = 0; i < 4; i++) { if (linhaCruzaLinha(p1, p2, retanguloPontos[i], retanguloPontos[(i + 1) % 4])) return true; } return false; }
export function linhaCruzaLinha(p1, p2, p3, p4) { const den = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x); if (den === 0) return null; const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / den; const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / den; if (t > 0 && t < 1 && u > 0 && u < 1) { return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) }; } return null; }
export function getLimites(pontos) { if (pontos.length === 0) return { minX: 0, maxX: 0, minY: 0, maxY: 0 }; const xCoords = pontos.map(p => p.x); const yCoords = pontos.map(p => p.y); return { minX: Math.min(...xCoords), maxX: Math.max(...xCoords), minY: Math.min(...yCoords), maxY: Math.max(...yCoords) }; }
export function encontrarComodoPai(elemento, todosOsComodos) { const limitesElemento = getLimites(elemento.pontos); const centroElemento = { x: (limitesElemento.minX + limitesElemento.maxX) / 2, y: (limitesElemento.minY + limitesElemento.maxY) / 2 }; for (const comodo of todosOsComodos) { if (comodo.id !== elemento.id && comodo.type === 'comodo') { if (pontoDentroPoligono(centroElemento, comodo.pontos)) return comodo; } } return null; }
export function calcularMedidasOrtogonais(coluna, comodoPai) { const centroColuna = { x: (getLimites(coluna.pontos).minX + getLimites(coluna.pontos).maxX) / 2, y: (getLimites(coluna.pontos).minY + getLimites(coluna.pontos).maxY) / 2 }; const anguloRad = coluna.rotacao * (Math.PI / 180); const cosA = Math.cos(anguloRad); const sinA = Math.sin(anguloRad); const direcoes = [ { x: cosA, y: sinA }, { x: -cosA, y: -sinA }, { x: -sinA, y: cosA }, { x: sinA, y: -cosA } ]; const pontosMedios = [ { x: centroColuna.x + (coluna.largura / 2) * cosA, y: centroColuna.y + (coluna.largura / 2) * sinA }, { x: centroColuna.x - (coluna.largura / 2) * cosA, y: centroColuna.y - (coluna.largura / 2) * sinA }, { x: centroColuna.x - (coluna.altura / 2) * sinA, y: centroColuna.y + (coluna.altura / 2) * cosA }, { x: centroColuna.x + (coluna.altura / 2) * sinA, y: centroColuna.y - (coluna.altura / 2) * cosA } ]; const medidas = []; for (let i = 0; i < direcoes.length; i++) { const origem = pontosMedios[i]; const direcao = direcoes[i]; const raioLongo = 1000; const pFinalRaio = { x: origem.x + direcao.x * raioLongo, y: origem.y + direcao.y * raioLongo }; let menorDist = Infinity; let pontoFinalMedida = null; for (let j = 0; j < comodoPai.pontos.length; j++) { const p1Parede = comodoPai.pontos[j]; const p2Parede = comodoPai.pontos[(j + 1) % comodoPai.pontos.length]; const intersecao = linhaCruzaLinha(origem, pFinalRaio, p1Parede, p2Parede); if (intersecao) { const dist = Math.sqrt((intersecao.x - origem.x)**2 + (intersecao.y - origem.y)**2); if (dist < menorDist) { const pontoMedioTeste = { x: (origem.x + intersecao.x) / 2, y: (origem.y + intersecao.y) / 2 }; if (pontoDentroPoligono(pontoMedioTeste, comodoPai.pontos)) { menorDist = dist; pontoFinalMedida = intersecao; } } } } if (pontoFinalMedida) { medidas.push({ p1: origem, p2: pontoFinalMedida, dist: menorDist }); } } return medidas; }
export function calcularViewportInicial(comodos, canvas) { if (!comodos || comodos.length === 0 || !canvas) { return { escala: 50, offsetX: 100, offsetY: 100 }; } const todosOsPontos = comodos.flatMap(c => c.pontos); if (todosOsPontos.length === 0) { return { escala: 50, offsetX: 100, offsetY: 100 }; } const limites = getLimites(todosOsPontos); const larguraMundo = limites.maxX - limites.minX; const alturaMundo = limites.maxY - limites.minY; if (larguraMundo === 0 || alturaMundo === 0) { return { escala: 50, offsetX: 100, offsetY: 100 }; } const padding = 1.2; const escalaX = canvas.clientWidth / (larguraMundo * padding); const escalaY = canvas.clientHeight / (alturaMundo * padding); const escala = Math.min(escalaX, escalaY); const centroMundoX = limites.minX + larguraMundo / 2; const centroMundoY = limites.minY + alturaMundo / 2; const offsetX = (canvas.clientWidth / 2) - (centroMundoX * escala); const offsetY = (canvas.clientHeight / 2) - (centroMundoY * escala); return { escala, offsetX, offsetY }; }